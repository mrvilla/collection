"use strict";
/**
 * Represents a simple http service, which returns a promise.
 *
 * @module http
 * @author Sebastian Fitzner
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// Imports
var base_1 = require("@veams/base");
var HttpService = /** @class */ (function (_super) {
    __extends(HttpService, _super);
    function HttpService(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        var namespace = '@veams/http-service';
        var defaultOptions = {
            url: null,
            type: 'text',
            method: 'GET',
            fetchOnInit: false,
            headers: null
        };
        _this = _super.call(this, { namespace: namespace, options: options }, defaultOptions) || this;
        _this.data = {};
        _this.initialize();
        return _this;
    }
    ;
    HttpService.prototype.initialize = function () {
        if (!window['Promise']) {
            console.error('@veams/http-service :: You should add a lightweight promise library like promise-polyfill!');
        }
        if (this.options.fetchOnInit) {
            return this.promiseRequest();
        }
    };
    ;
    // Request lifecycle
    HttpService.prototype.requestWillOpen = function (request, obj) {
    };
    HttpService.prototype.requestDidOpen = function (request, obj) {
        if (this.options.headers) {
            for (var header in this.options.headers) {
                if (this.options.headers.hasOwnProperty(header)) {
                    request.setRequestHeader(header, this.options.headers[header]);
                }
            }
        }
    };
    HttpService.prototype.requestWillLoad = function (request, obj) {
    };
    HttpService.prototype.requestDidLoad = function (request, obj) {
    };
    HttpService.prototype.requestWillSend = function (request, obj) {
    };
    HttpService.prototype.requestDidSend = function (request, obj) {
    };
    // Request function
    HttpService.prototype.promiseRequest = function (obj) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var request = new XMLHttpRequest();
            var data = obj.type === 'json' ? JSON.stringify(obj.data) : obj.data;
            _this.requestWillOpen(request, obj);
            request.open(obj.method, obj.url, true);
            _this.requestDidOpen(request, obj);
            _this.requestWillLoad(request, obj);
            request.onload = function () {
                if (request.status >= 200 && request.status < 400) {
                    resolve(_this.parser({
                        request: request,
                        type: obj.type
                    }));
                    _this.requestDidLoad(request, obj);
                }
                else {
                    reject({
                        status: request.status,
                        statusText: request.statusText
                    });
                    _this.requestDidLoad(request, obj);
                }
            };
            request.onerror = function () {
                reject({
                    status: request.status,
                    statusText: request.statusText
                });
            };
            _this.requestWillSend(request, obj);
            request.send(data);
            _this.requestDidSend(request, obj);
        });
    };
    ;
    HttpService.prototype.get = function (url) {
        if (url === void 0) { url = null; }
        var requestObject = {};
        this.options.method = requestObject.method = 'GET';
        this.options.url = requestObject.url = url || this.options.url;
        this.options.type = requestObject.type = this.options.type;
        return this.promiseRequest(requestObject);
    };
    ;
    HttpService.prototype.delete = function (url) {
        if (url === void 0) { url = null; }
        var requestObject = {};
        requestObject.method = 'DELETE';
        requestObject.url = url || this.options.url;
        // requestObject.type = this.options.type;
        return this.promiseRequest(requestObject);
    };
    HttpService.prototype.post = function (url, data) {
        if (url === void 0) { url = null; }
        var requestObject = {};
        requestObject.data = data ? data : null;
        requestObject.method = 'POST';
        requestObject.url = url || this.options.url;
        requestObject.type = this.options.type;
        if (this.options.type === 'json' && this.options.headers === null) {
            this.options.headers = {
                'content-type': 'application/json'
            };
        }
        return this.promiseRequest(requestObject);
    };
    HttpService.prototype.put = function (url, data) {
        if (url === void 0) { url = null; }
        var requestObject = {};
        requestObject.data = data ? data : null;
        requestObject.method = 'PUT';
        requestObject.url = url || this.options.url;
        requestObject.type = this.options.type;
        if (this.options.type === 'json' && this.options.headers === null) {
            this.options.headers = {
                'content-type': 'application/json'
            };
        }
        return this.promiseRequest(requestObject);
    };
    /**
     * The default parser, which returns the response text.
     * This method can be overridden.
     *
     * @param {Object} obj - Generic object.
     * @param {Object} obj.request - Request object.
     * @param {String} obj.type - Define a type for the response text.
     * @param {Object} obj.data - Data object.
     */
    HttpService.prototype.parser = function (obj) {
        this.data = obj.request.responseText;
        if (obj.type === 'json') {
            this.data = JSON.parse(this.data);
        }
        return this.data;
    };
    return HttpService;
}(base_1.default));
exports.default = HttpService;
//# sourceMappingURL=index.js.map