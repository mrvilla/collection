/**
 * TODO: Clean up mutation observer
 */
/**
 * - Get modules in DOM
 * - Get classes and options from init process
 * - Split up conditional modules from initial modules
 * - Init other modules
 * - Bind events when available from conditional modules
 * -
 */
/**
 * Interface
 */
export interface PluginOptions {
    attrPrefix?: string;
    attrName?: string;
    attrOptions?: string;
    logs?: boolean;
    internalCacheOnly?: boolean;
    internalRegisterOnly?: boolean;
    useMutationObserver?: boolean;
}
export interface Module {
    namespace: string;
    module: any;
    options?: object;
    render?: boolean;
    cb?: any;
}
/**
 * Module Class
 */
declare class Modules {
    options: PluginOptions;
    private _cache;
    private _register;
    queryString: string;
    /**
     * Constructor
     */
    constructor(VEAMS: any, opts: any);
    initialize(): void;
    bindEvents(): void;
    /**
     * Save the module in __cache.
     *
     * @param {Object} module - module metadata object (@see VeamsComponent.metaData())
     * @param {Object} element - module element (this.el)
     * @param {Object} instance - module instance
     * @param {String} namespace - module namespace
     */
    static addToCache({module, element, instance, namespace}: {
        module: any;
        element: any;
        instance: any;
        namespace: any;
    }): void;
    static removeFromCacheByKey(obj: any, key?: string): void;
    static checkModuleInCache(obj: any, key?: string, namespace?: any): boolean;
    static isCondition({conditions}: {
        conditions: any;
    }): boolean;
    static makeConditionCheck({conditions}: {
        conditions: any;
    }): boolean;
    bindConditions(): void;
    bindCondition(module: any): void;
    /**
     * Split up modules depending on condition check
     */
    splitUpModules(): void;
    /**
     * Add module to cache
     */
    addModuleToCache(obj: any): void;
    /**
     * Register multiple modules.
     *
     * @param {Array} arr - Array which contains the modules as object.
     *
     * @public
     */
    register(arr: Module[]): void;
    add(...module: any[]): void;
    /**
     * Register all modules
     */
    registerAll(): void;
    /**
     * Register all initial modules
     */
    registerInitialModules(): void;
    /**
     * Register conditional modules
     *
     * Therefore we check the condition and
     * when true register the specific module
     * when false unregister the specific module
     */
    registerConditionalModules(): void;
    registerConditionalModule(obj: any): void;
    /**
     * Register one module and init the elements in the specific context
     *
     * @param {String} namespace - Required: element name in DOM
     * @param {String} domName - Required: element name in DOM
     * @param {Object} module - Required: class which will be used to render your module
     * @param {boolean} [render=true] - Optional: render the class, if false the class will only be initialized
     * @param {function} [cb] - Optional: provide a function which will be executed after initialisation
     * @param {Object} [options] - Optional: You can pass options to the module via JS (Useful for DOMChanged)
     *
     */
    registerOne({namespace, domName, module, render, cb, options}: {
        namespace: any;
        domName: any;
        module: any;
        render: any;
        cb: any;
        options: any;
    }): void;
    unregisterOne({namespace}: {
        namespace: any;
    }): void;
    /**
     * Initialize a module and render it and/or provide a callback function
     *
     * @param {string} namespace - Required: dom name of the element
     * @param {Object} module - Required: class which will be used to render your module
     * @param {boolean} [render=true] - Optional: render the class, if false the class will only be initialized
     * @param {Object} [options] - Optional: You can pass options to the module via JS (Useful for DOMChanged)
     * @param {function} [cb] - Optional: provide a function which will be executed after initialisation
     *
     */
    initModules({namespace, module, render, options, cb}: Module): void;
    initModule({el, namespace, options, module, render, cb}: {
        el: any;
        namespace: any;
        options?: {};
        module: any;
        render?: boolean;
        cb?: null;
    }): void;
    /**
     * Add mutation observer to observe new modules.
     *
     * @param {Object} context - Context for the mutation observer
     *
     * TODO: Improve for loops
     */
    observe(context: any): void;
    /**
     * Get Modules in a specific context.
     *
     * @param {Object} context - Context for query specific string
     */
    getModulesInContext(context: any): any[];
}
/**
 * Plugin Object
 */
declare const VeamsModules: {
    options: PluginOptions;
    pluginName: string;
    initialize: (Veams: any, opts?: PluginOptions) => void;
};
export default VeamsModules;
export { Modules };
